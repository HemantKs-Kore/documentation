<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>koreai documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">koreai documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li>Interfaces</li>
  <li
  >
  SelectionRectangle</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>apps/searchassist/src/app/components/annotool/components/pdf-annotation/pdf-annotation.component.ts</code>
        </p>




        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#height" 
>
                                            height
                                        </a>
                                </li>
                                <li>
                                        <a href="#left" 
>
                                            left
                                        </a>
                                </li>
                                <li>
                                        <a href="#top" 
>
                                            top
                                        </a>
                                </li>
                                <li>
                                        <a href="#width" 
>
                                            width
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="height"></a>
                                        <span class="name "><b>height</b>
                                            <a href="#height">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>height:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="left"></a>
                                        <span class="name "><b>left</b>
                                            <a href="#left">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>left:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="top"></a>
                                        <span class="name "><b>top</b>
                                            <a href="#top">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>top:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="width"></a>
                                        <span class="name "><b>width</b>
                                            <a href="#width">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>width:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {
  Component,
  OnInit,
  OnChanges,
  ViewEncapsulation,
  ViewChild,
  HostListener,
  Inject,
} from &#x27;@angular/core&#x27;;
import {
  PdfViewerComponent,
  PDFProgressData,
  PdfViewerModule,
} from &#x27;ng2-pdf-viewer&#x27;;
import * as $ from &#x27;jquery&#x27;;
import SimpleBar from &#x27;simplebar/dist/simplebar-core.esm&#x27;;
import { Platform } from &#x27;@angular/cdk/platform&#x27;;

import {
  MatDialog,
  MatDialogRef,
  MAT_DIALOG_DATA,
} from &#x27;@angular/material/dialog&#x27;;
import {
  FormGroup,
  FormBuilder,
  Validators,
  ReactiveFormsModule,
} from &#x27;@angular/forms&#x27;;
import { ServiceInvokerService } from &#x27;../../../../services/service-invoker.service&#x27;;
import { RangySelectionService } from &#x27;../../services/rangy-selection.service&#x27;;

import { UserGuideComponent } from &#x27;../user-guide/user-guide.component&#x27;;
import {
  PerfectScrollbarComponent,
  PerfectScrollbarModule,
} from &#x27;ngx-perfect-scrollbar&#x27;;
import { NotificationService } from &#x27;../../../../services/notification.service&#x27;;
import { WorkflowService } from &#x27;../../../../services/workflow.service&#x27;;
import { SummaryModalComponent } from &#x27;../summary-modal/summary-modal.component&#x27;;
import { ConfirmationComponent } from &#x27;../confirmation/confirmation.component&#x27;;
import { NgbDropdownModule } from &#x27;@ng-bootstrap/ng-bootstrap&#x27;;
import { MatProgressBarModule } from &#x27;@angular/material/progress-bar&#x27;;
import { SimplebarAngularModule } from &#x27;simplebar-angular&#x27;;

@Component({
  selector: &#x27;kr-pdf-annotation&#x27;,
  standalone: true,
  templateUrl: &#x27;./pdf-annotation.component.html&#x27;,
  styleUrls: [&#x27;./pdf-annotation.component.scss&#x27;],
  encapsulation: ViewEncapsulation.None,
  imports: [
    ReactiveFormsModule,
    NgbDropdownModule,
    MatProgressBarModule,
    PdfViewerModule,
    SimplebarAngularModule,
    PerfectScrollbarModule,
  ],
})
export class PdfAnnotationComponent implements OnInit, OnChanges {
  @ViewChild(PdfViewerComponent)
  private pdfComponent: PdfViewerComponent;
  @ViewChild(&#x27;perfectScroll&#x27;) perfectScroll: PerfectScrollbarComponent;
  options &#x3D; {
    autoHide: true,
    scrollbarMinSize: 100,
    classNames: {
      content: &#x27;simplebar-content&#x27;,
      scrollContent: &#x27;simplebar-scroll-content&#x27;,
      scrollbar: &#x27;simplebar-scrollbar&#x27;,
      track: &#x27;simplebar-track&#x27;,
    },
    direction: &#x27;rtl&#x27;,
  };
  pdfConfig &#x3D; {
    rotate: 0,
    zoom: 1.03,
    renderTextMode: 2,
    currentPage: 1,
    totalPages: 0,
    renderText: true,
    originalSize: false,
    autoResize: true,
    showAll: false,
    fitToPage: false,
    pdfUrl: &#x27;&#x27;,
  };
  loaderFlag &#x3D; false;
  public hostRectangle: SelectionRectangle | null;
  public overRectange: SelectionRectangle | null;
  private selectedText: string;
  pdfForm: FormGroup;
  rangyHightlights: any &#x3D; null;
  rangySerialization: Object &#x3D; null;
  rangySaveSelection: Object &#x3D; null;
  pdfPayload &#x3D; {
    pdfsize: [],
    parentCanvas: {
      width: 0,
      height: 0,
    },
    title: [],
    header: [],
    footer: [],
    ignoreText: [],
    title_pageno: [],
    header_pageno: [],
    footer_pageno: [],
    ignoreTextPageno: [],
    ignorePages: [],
    serialization: [],
    streamId: null,
    pdfUrl: &#x27;&#x27;,
  };
  extractionLoader &#x3D; false;
  streamId: string &#x3D; null;
  pdfSize &#x3D; &#x27;0 KB&#x27;;
  fileId: string &#x3D; null;
  sourceId: string &#x3D; null;
  fileName: string &#x3D; null;
  togglePage &#x3D; false;
  removeAnnotationFlag &#x3D; false;
  saveSelection: any;
  restoreSelection: any;
  removalText &#x3D; &#x27;&#x27;;
  overStateEvent: any &#x3D; null;
  removeClassName &#x3D; &#x27;&#x27;;
  pdfProgressPerc &#x3D; 0;
  form: FormGroup;
  private themeWrapper &#x3D; document.querySelector(&#x27;body&#x27;);
  removeProgressBar &#x3D; false;
  selectedApp: any &#x3D; {};
  searchIndexId &#x3D; &#x27;&#x27;;

  constructor(
    private _formBuilder: FormBuilder,
    public workflowService: WorkflowService,
    private service: ServiceInvokerService,
    private notificationService: NotificationService,
    private rangeService: RangySelectionService,
    public dialog: MatDialog,
    public dialogRef: MatDialogRef&lt;PdfAnnotationComponent&gt;,
    @Inject(MAT_DIALOG_DATA) public dialogData: any,
    public platform: Platform
  ) {
    this.createForm();
    this.initPdfViewer();
  }

  ngOnInit() {
    // this.userGuide();
    this.getSavedAnnotatedDataForStream();
    this.formUpdatation();
    this.createThemeForm();
    this.applyTheme(this.form.value); // Make sure apply default colors
    const simpleBar &#x3D; new SimpleBar(document.getElementById(&#x27;simpleBar&#x27;));
    simpleBar.getScrollElement().addEventListener(&#x27;scroll&#x27;, this.onScrollEvent);
  }
  ngAfterViewInit() {
    // console.log(this.pdfComponent);
  }
  ngOnChanges() {}
  ngOnDestroy() {
    window.removeEventListener(&#x27;mouseup&#x27;, this.textLayerMouseup, false);
    window.removeEventListener(&#x27;mouseover&#x27;, this.onMouse, false);
    window.removeEventListener(&#x27;scroll&#x27;, this.onScrollEvent, true);
    this.pdfComponent.clear();
  }
  closeModal(msg) {
    this.dialogRef.close(msg);
  }
  // Init data for pdf-viwer
  initPdfViewer() {
    this.selectedApp &#x3D; this.workflowService.selectedApp();
    this.searchIndexId &#x3D; this.selectedApp.searchIndexes[0]._id;
    this.pdfPayload.streamId &#x3D; this.selectedApp._id;
    this.streamId &#x3D; this.selectedApp._id;
    if (
      this.dialogData &amp;&amp;
      this.dialogData.type &amp;&amp;
      this.dialogData.type &#x3D;&#x3D;&#x3D; &#x27;reannotate&#x27; &amp;&amp;
      this.dialogData.source
    ) {
      this.reAnnotateDocument(this.dialogData.source);
    } else if (
      this.dialogData &amp;&amp;
      this.dialogData.type &amp;&amp;
      this.dialogData.type &#x3D;&#x3D;&#x3D; &#x27;resumeAnnotate&#x27;
    ) {
      if (this.dialogData.pdfResponse) {
        this.fileId &#x3D; this.dialogData.pdfResponse.fileId;
        this.fileName &#x3D; this.dialogData.pdfResponse.sourceTitle;
        this.sourceId &#x3D; this.dialogData.pdfResponse.sourceId;
      }
      this.reAnnotateDocument(this.dialogData.pdfResponse);
    } else {
      if (this.dialogData.pdfResponse) {
        this.fileId &#x3D; this.dialogData.pdfResponse.fileId;
        this.fileName &#x3D; this.dialogData.pdfResponse.sourceTitle;
        this.sourceId &#x3D; this.dialogData.pdfResponse.sourceId;
      }
      this.getAttachmentFile(this.fileId);
    }
  }
  // User Guilde - How to annotate
  userGuide() {
    setTimeout(() &#x3D;&gt; {
      const payload &#x3D; {
        header: &#x27;How to Annotate&#x27;,
        body: {},
        footer: &#x27;Learn more&#x27;,
        backToSource: false,
      };
      const dialogRef &#x3D; this.dialog.open(UserGuideComponent, {
        data: { pdfResponse: payload },
        panelClass: &#x27;kr-create-app-panel&#x27;,
        disableClose: true,
        autoFocus: false,
      });
      dialogRef.afterClosed().subscribe((res) &#x3D;&gt; {
        // console.log(payload);
        if (payload &amp;&amp; payload.backToSource) {
          if (res) {
            this.closeModal(res);
          }
        }
      });
    }, 1000);
  }

  confirmText() {
    const getRmvTxt &#x3D; getAllElements(
      this.overStateEvent,
      this.removeClassName,
      this.pdfPayload
    );
    if (getRmvTxt &#x3D;&#x3D;&#x3D; this.removalText &amp;&amp; this.cancelData(this.removalText)) {
      removeTextClass(this.removeClassName, this.overStateEvent); // remove sibling classes
      this.cancelData(this.removalText); // Pass text to delete from original Payload
      this.removeProgressBar &#x3D; true;
      $(&#x27;.pdf-viewer&#x27;).css(&#x27;width&#x27;, $(&#x27;.pdf-viewer&#x27;).width() + 1);
      this.pdfComponent.updateSize();
      this.pdfConfig.zoom &#x3D; this.pdfConfig.zoom;
      setTimeout(() &#x3D;&gt; {
        this.removeProgressBar &#x3D; false;
      }, 150);
    } else {
      this.removeConfirmDialog();
    }

    this.removalText &#x3D; &#x27;&#x27;;
    this.removeAnnotationFlag &#x3D; false;
    this.overRectange &#x3D; null;
    this.overStateEvent &#x3D; null;
    this.removeClassName &#x3D; &#x27;&#x27;;
  }
  cancelText() {
    this.removalText &#x3D; &#x27;&#x27;;
    this.overRectange &#x3D; null;
    this.removeAnnotationFlag &#x3D; false;
    this.overStateEvent &#x3D; null;
    this.removeClassName &#x3D; &#x27;&#x27;;
  }
  // OnHover of highlighted text
  @HostListener(&#x27;mouseover&#x27;, [&#x27;$event&#x27;]) onMouse($event) {
    if (this.hostRectangle) {
      return false;
    }
    $event.preventDefault();
    $event.stopPropagation();
    $(&#x27;.remove-indicator&#x27;).show();
    if ($event.target.className &#x3D;&#x3D;&#x3D; ClassTypes.heading) {
      // Heading
      this.removeAnnotationFlag &#x3D; false;
      const boundry &#x3D; $event.target.getBoundingClientRect();
      this.overRectange &#x3D; {
        left: boundry.left,
        top: boundry.top,
        width: boundry.width,
        height: boundry.height,
      };
      this.removalText &#x3D; getAllElements(
        $event.target,
        ClassTypes.heading,
        this.pdfPayload
      ); // Sum prev, current &amp; next string
      this.overStateEvent &#x3D; $event.target;
      this.removeClassName &#x3D; $event.target.className;
    } else if ($event.target.className &#x3D;&#x3D;&#x3D; ClassTypes.header) {
      // Header
      this.removeAnnotationFlag &#x3D; false;
      const boundry &#x3D; $event.target.getBoundingClientRect();
      this.overRectange &#x3D; {
        left: boundry.left,
        top: boundry.top,
        width: boundry.width,
        height: boundry.height,
      };
      this.removalText &#x3D; getAllElements(
        $event.target,
        ClassTypes.header,
        this.pdfPayload
      ); // Sum prev, current &amp; next string
      this.overStateEvent &#x3D; $event.target;
      this.removeClassName &#x3D; $event.target.className;
    } else if ($event.target.className &#x3D;&#x3D;&#x3D; ClassTypes.exclude) {
      // Ignore text
      this.removeAnnotationFlag &#x3D; false;
      const boundry &#x3D; $event.target.getBoundingClientRect();
      this.overRectange &#x3D; {
        left: boundry.left,
        top: boundry.top,
        width: boundry.width,
        height: boundry.height,
      };
      this.removalText &#x3D; getAllElements(
        $event.target,
        ClassTypes.exclude,
        this.pdfPayload
      ); // Sum prev, current &amp; next string
      this.overStateEvent &#x3D; $event.target;
      this.removeClassName &#x3D; $event.target.className;
    } else if ($event.target.className &#x3D;&#x3D;&#x3D; ClassTypes.footer) {
      // Footer
      this.removeAnnotationFlag &#x3D; false;
      const boundry &#x3D; $event.target.getBoundingClientRect();
      this.overRectange &#x3D; {
        left: boundry.left,
        top: boundry.top,
        width: boundry.width,
        height: boundry.height,
      };
      this.removalText &#x3D; getAllElements(
        $event.target,
        ClassTypes.footer,
        this.pdfPayload
      ); // Sum prev, current &amp; next string
      this.overStateEvent &#x3D; $event.target;
      this.removeClassName &#x3D; $event.target.className;
    }
  }
  // On scroll evnt
  onScrollEvent($event) {
    $(&#x27;.remove-indicator&#x27;).hide();
    this.overRectange &#x3D; null;
    this.removeAnnotationFlag &#x3D; false;
  }
  scrollHandler(event) {
    const x: any &#x3D; this.perfectScroll.directiveRef.position(true).x || 0;
    const y: any &#x3D; this.perfectScroll.directiveRef.position(true).y || 0;
    this.perfectScroll.directiveRef.update(); //for update scroll
    this.perfectScroll.directiveRef.scrollTo(0, 0, 100);
  }

  @HostListener(&#x27;document:keydown.escape&#x27;, [&#x27;$event&#x27;]) onKeydownHandler(
    event: KeyboardEvent
  ) {
    this.overRectange &#x3D; null;
    this.removeAnnotationFlag &#x3D; false;
    document.getSelection().removeAllRanges(); // Clear selection range
    this.hostRectangle &#x3D; null;
  }

  // Create form
  createForm() {
    this.pdfForm &#x3D; this._formBuilder.group({
      inputValue: [null, [Validators.required]],
      className: [null],
      currentPage: [1],
      totalPages: [null],
      ignorePages: [null],
      pdfSize: [null],
      pdfHeight: [null],
      pdfWidth: [null],
      titleObj: this._formBuilder.array([]),
      subTitleObj: this._formBuilder.array([]),
      headerObj: this._formBuilder.array([]),
    });
  }
  // Form reset
  formReset() {
    this.pdfForm.reset();
    this.pdfPayload &#x3D; {
      pdfsize: [],
      parentCanvas: {
        width: 0,
        height: 0,
      },
      title: [],
      header: [],
      footer: [],
      ignoreText: [],
      title_pageno: [],
      header_pageno: [],
      footer_pageno: [],
      ignoreTextPageno: [],
      ignorePages: [],
      serialization: [],
      streamId: this.streamId,
      pdfUrl: this.pdfConfig.pdfUrl,
    };
  }
  // FormUpdatation
  formUpdatation() {
    this.pdfForm.get(&#x27;inputValue&#x27;).valueChanges.subscribe((res) &#x3D;&gt; {
      if (res) {
        switch (res) {
          case &#x27;1&#x27;:
            this.pdfForm.get(&#x27;className&#x27;).setValue(ClassTypes.heading);
            break;
          case &#x27;2&#x27;:
            this.pdfForm.get(&#x27;className&#x27;).setValue(ClassTypes.header);
            break;
          case &#x27;3&#x27;:
            this.pdfForm.get(&#x27;className&#x27;).setValue(ClassTypes.exclude);
            break;
          case &#x27;4&#x27;:
            this.pdfForm.get(&#x27;className&#x27;).setValue(ClassTypes.footer);
            break;
          default:
            this.pdfForm.get(&#x27;className&#x27;).setValue(&#x27;no-found&#x27;);
            break;
        }
        // setTimeout(() &#x3D;&gt; {
        // this.rangyHightlights &#x3D; this.rangeService.getTextHighlighter(this.pdfForm.get(&quot;className&quot;).value);
        // }, 500);
        // console.log(this.rangyHightlights);
      }
    });
  }

  pageRendered(event: any) {
    // console.log(event);
    this.pdfForm.get(&#x27;pdfHeight&#x27;).setValue(event.source.viewport.height || 0);
    this.pdfForm.get(&#x27;pdfWidth&#x27;).setValue(event.source.viewport.width || 0);
    // this.pdfConfig.currentPage &#x3D; event.pageNumber;
    this.updateIgnorePages();
    // setTimeout(() &#x3D;&gt; {
    this.deserializeObj(); // reform highlighted text
    // }, 1000);
  }

  // Page changing
  pagechanging(e: any) {
    this.pdfConfig.currentPage &#x3D; e.pageNumber; // the page variable
  }
  // PDF error handling
  onError(error: any) {
    // console.log(error);
    this.notificationService.notify(&#x27;Something went wrong with pdf&#x27;, &#x27;error&#x27;);
  }
  // Onprogress pdf percentage
  onProgress(progressData: PDFProgressData) {
    this.pdfProgressPerc &#x3D;
      (progressData.loaded / progressData.total) * 100 || 0;
  }
  // Get file from server
  getAttachmentFile(fileId) {
    this.formReset();
    this.loaderFlag &#x3D; true;
    this.service.invoke(&#x27;attachment.file&#x27;, { fileId: fileId }, {}).subscribe(
      (res: any) &#x3D;&gt; {
        this.pdfConfig.pdfUrl &#x3D; res.fileUrl;
      },
      (error: any) &#x3D;&gt; {
        this.loaderFlag &#x3D; false;
        this.notificationService.notify(error.error.errors[0].msg, &#x27;error&#x27;);
      }
    );
  }
  // text layer render - rewriting span&#x27;s with div elements
  textLayerRendered(e: CustomEvent) {
    // console.log(e);
    const divs &#x3D; document.querySelectorAll(&#x27;.textLayer &gt; span&#x27;);
    for (let i &#x3D; 0; i &lt; divs.length; i++) {
      const s: any &#x3D; document.createElement(&#x27;div&#x27;);
      s.style &#x3D; divs[i].getAttribute(&#x27;style&#x27;);
      s.innerHTML &#x3D; divs[i].innerHTML;
      divs[i].outerHTML &#x3D; s.outerHTML;
    }
  }
  // After PDF load completes
  afterLoadComplete(pdfData: any) {
    // console.log(pdfData);
    if (
      pdfData &amp;&amp;
      pdfData.loadingTask &amp;&amp;
      pdfData.loadingTask._transport &amp;&amp;
      pdfData.loadingTask._transport._lastProgress
    ) {
      let _size &#x3D; pdfData.loadingTask._transport._lastProgress.total;
      let fSExt &#x3D; [&#x27;Bytes&#x27;, &#x27;KB&#x27;, &#x27;MB&#x27;, &#x27;GB&#x27;],
        i &#x3D; 0;
      while (_size &gt; 900) {
        _size /&#x3D; 1024;
        i++;
      }
      const exactSize: string &#x3D;
        (Math.round(_size * 100) / 100).toFixed() + &#x27;&#x27; + fSExt[i];
      this.pdfSize &#x3D; exactSize;
    }
    this.pdfForm.get(&#x27;totalPages&#x27;).setValue(pdfData.numPages);
    this.pdfConfig.totalPages &#x3D; pdfData.numPages;
    setTimeout(() &#x3D;&gt; {
      this.loaderFlag &#x3D; false;
      this.deserializeObj();
    }, 200);
  }

  nextPage() {
    this.pdfConfig.currentPage++;
    this.pdfForm.get(&#x27;currentPage&#x27;).setValue(this.pdfConfig.currentPage);
    this.updateIgnorePages();
    this.deserializeObj();
  }
  prevPage() {
    this.pdfConfig.currentPage--;
    this.pdfForm.get(&#x27;currentPage&#x27;).setValue(this.pdfConfig.currentPage);
    this.updateIgnorePages();
    this.deserializeObj();
  }
  zoom() {
    this.pdfConfig.zoom +&#x3D; 0.1;
  }
  zoomOut() {
    this.pdfConfig.zoom -&#x3D; 0.1;
  }
  rotateClock() {
    this.pdfConfig.rotate +&#x3D; 90;
  }
  rotateAntiClock() {
    this.pdfConfig.rotate -&#x3D; 90;
  }
  // test hightlight text
  optionSelection(classTypes, value, $event) {
    // $event.stopPropagation();
    this.pdfForm.get(&#x27;inputValue&#x27;).setValue(value);
    this.pdfForm.get(&#x27;className&#x27;).setValue(classTypes);
    this.rangyHightlights &#x3D; this.rangeService.getTextHighlighter(classTypes);
    // if(this.rangySerialization) {
    //   console.log(this.rangyHightlights, this.rangySerialization);
    //   this.rangeService.singleDeserialization({ coords: this.rangySerialization, className: this.pdfForm.get(&quot;className&quot;).value, currentPage: this.pdfConfig.currentPage }) // DOM selection removed, then do deserilization
    // }
    if (this.selectedText) {
      this.updatePayload(); // payload construction
      this.hostRectangle &#x3D; null;
      this.selectedText &#x3D; &#x27;&#x27;;
    }
    document.getSelection().removeAllRanges(); // Clear selection range
    this.pdfForm.get(&#x27;inputValue&#x27;).reset();
    this.pdfForm.get(&#x27;className&#x27;).reset();
  }
  // Cancel Data / Delete data from highlighted text
  cancelData(selectedText) {
    if (selectedText) {
      if (this.pdfPayload.title.includes(selectedText)) {
        const index &#x3D; this.pdfPayload.title.indexOf(selectedText);
        this.pdfPayload.title.splice(index, 1);
        this.pdfPayload.title_pageno.splice(index, 1);
        this.cancelSerializationData(selectedText);
      } else if (this.pdfPayload.header.includes(selectedText)) {
        const index &#x3D; this.pdfPayload.header.indexOf(selectedText);
        this.pdfPayload.header.splice(index, 1);
        this.pdfPayload.header_pageno.splice(index, 1);
        this.cancelSerializationData(selectedText);
      } else if (this.pdfPayload.footer.includes(selectedText)) {
        const index &#x3D; this.pdfPayload.footer.indexOf(selectedText);
        this.pdfPayload.footer.splice(index, 1);
        this.pdfPayload.footer_pageno.splice(index, 1);
        this.cancelSerializationData(selectedText);
      } else if (this.pdfPayload.ignoreText.includes(selectedText)) {
        const index &#x3D; this.pdfPayload.ignoreText.indexOf(selectedText);
        this.pdfPayload.ignoreText.splice(index, 1);
        this.pdfPayload.ignoreTextPageno.splice(index, 1);
        this.cancelSerializationData(selectedText);
      } else {
        // console.log(&quot;No selected text found with Orginal data&quot;);
        return false;
      }
      this.autoSaveAnno(); // Autosave annotation
      return true;
    }
  }
  // Update Payload
  updatePayload() {
    if (this.selectedText &amp;&amp; this.pdfForm.get(&#x27;inputValue&#x27;).value) {
      this.pdfPayload[&#x27;parentCanvas&#x27;].height &#x3D;
        this.pdfForm.get(&#x27;pdfHeight&#x27;).value;
      this.pdfPayload[&#x27;parentCanvas&#x27;].width &#x3D;
        this.pdfForm.get(&#x27;pdfWidth&#x27;).value;
      if (this.pdfForm.get(&#x27;inputValue&#x27;).value &#x3D;&#x3D;&#x3D; &#x27;1&#x27;) {
        this.pdfPayload.title.push(this.selectedText);
        this.pdfPayload.title_pageno.push(this.pdfConfig.currentPage);
      } else if (this.pdfForm.get(&#x27;inputValue&#x27;).value &#x3D;&#x3D;&#x3D; &#x27;2&#x27;) {
        this.pdfPayload.header.push(this.selectedText);
        this.pdfPayload.header_pageno.push(this.pdfConfig.currentPage);
      } else if (this.pdfForm.get(&#x27;inputValue&#x27;).value &#x3D;&#x3D;&#x3D; &#x27;3&#x27;) {
        this.pdfPayload.footer.push(this.selectedText);
        this.pdfPayload.footer_pageno.push(this.pdfConfig.currentPage);
      } else if (this.pdfForm.get(&#x27;inputValue&#x27;).value &#x3D;&#x3D;&#x3D; &#x27;4&#x27;) {
        this.pdfPayload.ignoreText.push(this.selectedText);
        this.pdfPayload.ignoreTextPageno.push(this.pdfConfig.currentPage);
      }
      // Update serilization coords
      if (this.rangySerialization) {
        this.pdfPayload.serialization.push({
          coords: this.rangySerialization,
          className: this.pdfForm.get(&#x27;className&#x27;).value,
          currentPage: this.pdfConfig.currentPage,
          selectedText: this.selectedText,
        });
      }
      this.autoSaveAnno(); // Autosave annotation
    }
  }
  // canel serilization data
  cancelSerializationData(text: string) {
    if (
      text &amp;&amp;
      this.pdfPayload.serialization &amp;&amp;
      this.pdfPayload.serialization.length
    ) {
      const index &#x3D; this.pdfPayload.serialization.findIndex(
        (res) &#x3D;&gt; res.selectedText &#x3D;&#x3D;&#x3D; text
      );
      this.pdfPayload.serialization.splice(index, 1);
    }
  }

  // Re-Annotate document on-demand
  reAnnotateDocument(listData) {
    this.formReset();
    this.loaderFlag &#x3D; true;
    this.service
      .invoke(&#x27;attachment.file&#x27;, { fileId: listData.fileId }, {})
      .subscribe(
        (res: any) &#x3D;&gt; {
          this.pdfConfig.pdfUrl &#x3D; res.fileUrl;
          this.service
            .invoke(&#x27;PdfAnno.get.reAnnotateData&#x27;, {
              searchIndexId: this.searchIndexId,
              fileId: listData.fileId,
              sourceId: listData.sourceId,
            })
            .subscribe(
              (res: any) &#x3D;&gt; {
                if (res &amp;&amp; res.Response) {
                  if (
                    res &amp;&amp;
                    res.Response !&#x3D;&#x3D;
                      &#x27;Annotated Data not available for this bot with this file Id&#x27;
                  ) {
                    this.notificationService.notify(res.Response, &#x27;success&#x27;);
                  }
                } else if (res.serialization) {
                  const sPayload &#x3D; {
                    title: res.title,
                    header: res.header,
                    footer: res.footer,
                    ignoreText: res.ignoreText,
                    title_pageno: res.titlePageno,
                    header_pageno: res.headerPageno,
                    footer_pageno: res.footerPageno,
                    ignoreTextPageno: res.ignoreTextPageno,
                    ignorePages: res.ignorePages,
                    serialization: res.serialization,
                    streamId: res.streamId,
                    fileId: res.fileId,
                    pdfUrl: this.pdfConfig.pdfUrl,
                    pdfsize: [this.pdfSize],
                    parentCanvas: {
                      width: this.pdfForm.get(&#x27;pdfWidth&#x27;).value,
                      height: this.pdfForm.get(&#x27;pdfHeight&#x27;).value,
                    },
                  };
                  this.pdfPayload &#x3D; sPayload;
                }
              },
              (error: any) &#x3D;&gt; {
                if (
                  error &amp;&amp;
                  error.data &amp;&amp;
                  error.data.errors &amp;&amp;
                  error.data.errors[0] &amp;&amp;
                  error.data.errors[0].msg
                ) {
                  this.notificationService.notify(
                    error.error.errors[0].msg,
                    &#x27;error&#x27;
                  );
                }
              }
            );
        },
        (error: any) &#x3D;&gt; {
          this.loaderFlag &#x3D; false;
          this.notificationService.notify(error.error.errors[0].msg, &#x27;error&#x27;);
        }
      );
    // console.log(listData);
  }
  // Check user guide info from api
  getSavedAnnotatedDataForStream() {
    this.service
      .invoke(&#x27;PdfAnno.get.userguide&#x27;, { streamId: this.pdfPayload.streamId })
      .subscribe(
        (res: any) &#x3D;&gt; {
          if (
            (res &amp;&amp; !res.userHasAnnotated &amp;&amp; !this.dialogData.type) ||
            (res &amp;&amp;
              !res.userHasAnnotated &amp;&amp;
              this.dialogData.type &amp;&amp;
              this.dialogData.type !&#x3D;&#x3D; &#x27;resumeAnnotate&#x27;)
          ) {
            this.userGuide();
          }
        },
        (error: any) &#x3D;&gt; {
          if (
            error &amp;&amp;
            error.data &amp;&amp;
            error.data.errors &amp;&amp;
            error.data.errors[0] &amp;&amp;
            error.data.errors[0].msg
          ) {
            this.notificationService.notify(error.error.errors[0].msg, &#x27;error&#x27;);
          }
        }
      );
  }
  // extract pdf
  extractPDF() {
    const payloadResponse &#x3D; {
      // &quot;streamId&quot;: this.pdfPayload.streamId,
      // &quot;fileId&quot;: this.fileId,
      title: this.pdfPayload.title,
      header: this.pdfPayload.header,
      footer: this.pdfPayload.footer,
      ignoreText: this.pdfPayload.ignoreText,
      titlePageno: this.pdfPayload.title_pageno,
      headerPageno: this.pdfPayload.header_pageno,
      footerPageno: this.pdfPayload.footer_pageno,
      ignoreTextPageno: this.pdfPayload.ignoreTextPageno,
      ignorePages: this.pdfPayload.ignorePages,
      // &#x27;name&#x27;: this.fileName,
      // &#x27;extractionType&#x27;: &#x27;annotation&#x27;
    };
    this.extractionLoader &#x3D; true;
    this.service
      .invoke(
        &#x27;PdfAnno.faq.annotateExtract&#x27;,
        {
          searchIndexId: this.searchIndexId,
          sourceType: &#x27;file&#x27;,
          sourceId: this.sourceId,
        },
        payloadResponse
      )
      .subscribe(
        (res: any) &#x3D;&gt; {
          this.extractionLoader &#x3D; false;
          this.dialogData.annotation.resourceId &#x3D; res?.resourceId;
          this.dialogData.annotation._id &#x3D; res._id;
          this.dialogData.annotation.status &#x3D; &#x27;Inprogress&#x27;;
          this.dialogData.annotation.annotationType &#x3D; true;
          this.closeModal(&#x27;pdf extracted&#x27;);
          this.rangeService.setPolling(true); // status progress
        },
        (error: any) &#x3D;&gt; {
          this.extractionLoader &#x3D; false;
          if (
            error &amp;&amp;
            error.error &amp;&amp;
            error.error.errors &amp;&amp;
            error.error.errors[0] &amp;&amp;
            error.error.errors[0].msg
          ) {
            this.notificationService.notify(error.error.errors[0].msg, &#x27;error&#x27;);
          }
        }
      );
  }
  // check form is valid/In valid
  get isFormValid() {
    if (Object.keys(this.pdfPayload).length) {
      if (
        this.pdfPayload.title.length ||
        this.pdfPayload.header.length ||
        this.pdfPayload.footer.length ||
        this.pdfPayload.ignoreText.length ||
        this.pdfPayload.ignorePages.length
      ) {
        return true;
      }
    } else {
      // NotificationService.notify(&quot;You can only review the questions once you have annotated and extracted&quot;, &#x27;error&#x27;);
      return false;
    }
  }
  // Auto Save Anntation
  autoSaveAnno() {
    if (!this.fileName) {
      console.log(this.fileName, &#x27;File name not found&#x27;);
    }
    const payloadResponse &#x3D; {
      // &quot;streamId&quot;: this.pdfPayload.streamId,
      // &quot;fileId&quot;: this.fileId,
      title: this.pdfPayload.title,
      header: this.pdfPayload.header,
      footer: this.pdfPayload.footer,
      ignoreText: this.pdfPayload.ignoreText,
      titlePageno: this.pdfPayload.title_pageno,
      headerPageno: this.pdfPayload.header_pageno,
      footerPageno: this.pdfPayload.footer_pageno,
      ignoreTextPageno: this.pdfPayload.ignoreTextPageno,
      ignorePages: this.pdfPayload.ignorePages,
      // &#x27;name&#x27;: this.fileName,
      // &#x27;extractionType&#x27;: &#x27;annotation&#x27;,
      serialization: this.pdfPayload.serialization,
      // &quot;autoSave&quot;: true
    };
    this.service
      .invoke(
        &#x27;PdfAnno.faq.annotate&#x27;,
        {
          searchIndexId: this.searchIndexId,
          sourceType: &#x27;file&#x27;,
          sourceId: this.sourceId,
        },
        payloadResponse
      )
      .subscribe(
        (res: any) &#x3D;&gt; {
          // console.log(res);
        },
        (error: any) &#x3D;&gt; {
          if (
            error &amp;&amp;
            error.error &amp;&amp;
            error.error.errors &amp;&amp;
            error.error.errors[0] &amp;&amp;
            error.error.errors[0].msg
          ) {
            this.notificationService.notify(error.error.errors[0].msg, &#x27;error&#x27;);
          }
        }
      );
  }
  // Confirmation dialog
  removeConfirmDialog() {
    if (
      this.pdfPayload.title.length ||
      this.pdfPayload.header.length ||
      this.pdfPayload.footer.length ||
      this.pdfPayload.ignoreText.length
    ) {
      const obj &#x3D; {
        title: &#x27;Confirmation&#x27;,
        confirmationMsg:
          &#x27;Data miss matching with orginal data, please click try again to delete manually.&#x27;,
        yes: &#x27;Try Again&#x27;,
        no: &#x27;Close&#x27;,
        type: &#x27;removeAnnotation&#x27;,
      };
      const dialogRef &#x3D; this.dialog.open(ConfirmationComponent, {
        data: { info: obj },
        panelClass: &#x27;kr-confirmation-panel&#x27;,
        disableClose: true,
        autoFocus: true,
      });
      dialogRef.afterClosed().subscribe((res) &#x3D;&gt; {
        if (res) {
          this.summaryDialog();
        }
      });
    } else {
      this.notificationService.notify(&#x27;Please select an option&#x27;, &#x27;error&#x27;);
    }
  }
  // Save pdf info
  summaryDialog() {
    if (
      this.pdfPayload.title.length ||
      this.pdfPayload.header.length ||
      this.pdfPayload.footer.length ||
      this.pdfPayload.ignoreText.length
    ) {
      const dialogRef &#x3D; this.dialog.open(SummaryModalComponent, {
        data: { pdfResponse: this.pdfPayload },
        panelClass: &#x27;kr-create-app-panel&#x27;,
        disableClose: true,
        autoFocus: true,
      });
      dialogRef.afterClosed().subscribe((res) &#x3D;&gt; {
        setTimeout(() &#x3D;&gt; {
          $(&#x27;.pdf-viewer&#x27;).css(&#x27;width&#x27;, $(&#x27;.pdf-viewer&#x27;).width() + 1);
          this.pdfComponent.updateSize();
          this.pdfConfig.zoom &#x3D; this.pdfConfig.zoom;
        }, 200);
      });
    } else {
      this.notificationService.notify(&#x27;Please select an option&#x27;, &#x27;error&#x27;);
    }
  }
  // Ignoraged pages
  ignorePages(event) {
    if (this.pdfForm.get(&#x27;ignorePages&#x27;).value) {
      this.pdfPayload.ignorePages.push(this.pdfConfig.currentPage);
      this.pdfConfig.renderTextMode &#x3D; 0;
      this.ignorePageAnnotation();
    } else {
      const index &#x3D; this.pdfPayload.ignorePages.indexOf(
        this.pdfConfig.currentPage
      );
      this.pdfPayload.ignorePages.splice(index, 1);
      this.pdfConfig.renderTextMode &#x3D; 2;
    }
    this.autoSaveAnno(); // Autosave annotation
  }
  // update ignore pages
  updateIgnorePages() {
    const index &#x3D; this.pdfPayload.ignorePages.indexOf(this.pdfConfig.currentPage);
    if (this.pdfPayload.ignorePages[index]) {
      this.pdfForm.get(&#x27;ignorePages&#x27;).setValue(true);
    } else {
      this.pdfForm.get(&#x27;ignorePages&#x27;).setValue(false);
    }
  }
  // Ignore pages need to remove annotation
  ignorePageAnnotation() {
    if (
      this.pdfPayload.serialization.length &amp;&amp;
      this.pdfPayload.ignorePages.length
    ) {
      const findPageNumber &#x3D; this.pdfPayload.ignorePages.indexOf(
        this.pdfConfig.currentPage
      );
      if (findPageNumber !&#x3D;&#x3D; -1) {
        const findObj &#x3D; this.pdfPayload.serialization.filter((obj) &#x3D;&gt; {
          return obj.currentPage &#x3D;&#x3D;&#x3D; this.pdfConfig.currentPage;
        });
        if (findObj &amp;&amp; findObj.length) {
          findObj.forEach((ser) &#x3D;&gt; {
            this.cancelData(ser.selectedText);
          });
        }
        $(&#x27;.pdf-viewer&#x27;).css(&#x27;width&#x27;, $(&#x27;.pdf-viewer&#x27;).width() + 1);
        this.pdfComponent.updateSize();
        this.pdfConfig.zoom &#x3D; this.pdfConfig.zoom;
      }
    }
  }
  // focusInput
  focusInput() {
    this.togglePage &#x3D; true;
    setTimeout(() &#x3D;&gt; {
      $(&#x27;#pageInput&#x27;).focus();
    }, 50);
  }
  // Search page number
  searchPage(event) {
    this.togglePage &#x3D; false;
    const number &#x3D; Number(event.target.value) || this.pdfConfig.currentPage || 1;
    if (number &lt;&#x3D; this.pdfConfig.totalPages) {
      this.pdfConfig.currentPage &#x3D; number;
      this.pdfConfig.totalPages &#x3D; this.pdfConfig.totalPages;
      this.pdfComponent.page &#x3D; number;
    } else {
      this.notificationService.notify(
        &#x27;Please enter a valid page number&#x27;,
        &#x27;error&#x27;
      );
    }
  }
  // Search text in PDF component
  searchText(text) {
    this.pdfComponent.pdfFindController.executeCommand(&#x27;find&#x27;, {
      caseSensitive: false,
      findPrevious: undefined,
      highlightAll: true,
      phraseSearch: true,
      query: text,
    });
  }
  // Mouse leave to remove range, popovers
  mouseLeavePDF($event) {
    setTimeout(() &#x3D;&gt; {
      this.hostRectangle &#x3D; null;
      this.overRectange &#x3D; null;
      this.removeAnnotationFlag &#x3D; false;
      document.getSelection().removeAllRanges(); // Clear selection range
    }, 2500);
  }
  // text layer mouseup
  textLayerMouseup($event) {
    setTimeout(() &#x3D;&gt; {
      this.selectedText &#x3D; getSelectionText();
      if (this.platform.FIREFOX) {
        // Firfox special chars
        this.selectedText &#x3D; this.selectedText.replace(/(\r\n|\n|\r)/gm, &#x27;&#x27;);
      }
      const contentHtml &#x3D; this.rangeService.rangeSelectionHtml();
      if (contentHtml &amp;&amp; checkDuplicateClasses(contentHtml)) {
        // check duplicate selection
        // console.log(&quot;It&#x27;s already annotated!&quot;);
        this.hostRectangle &#x3D; null;
        return false;
      } else if (!this.selectedText) {
        this.hostRectangle &#x3D; null;
      } else {
        if (this.selectedText) {
          this.overRectange &#x3D; null;
          this.hostRectangle &#x3D; null;
          this.hostRectangle &#x3D; this.rangeService.viewportRectangle();
          if (this.hostRectangle &amp;&amp; Math.sign(this.hostRectangle.top) &#x3D;&#x3D;&#x3D; -1) {
            const rectange: any &#x3D; {};
            rectange.top &#x3D; 100;
            rectange.left &#x3D; this.hostRectangle.left;
            this.hostRectangle &#x3D; null;
            this.hostRectangle &#x3D; rectange;
          }
          this.updatePayload();
          this.rangySerialization &#x3D; this.rangeService.getSerilization();
        } else {
        }
      }
    }, 50);
  }

  // Deserialize modal to rehightlight text after delay
  deserializeObj() {
    if (this.pdfPayload.serialization) {
      this.removeProgressBar &#x3D; false;
      setTimeout(() &#x3D;&gt; {
        const filteredRes &#x3D; this.pdfPayload.serialization.filter((val, index) &#x3D;&gt; {
          return val.currentPage &#x3D;&#x3D; this.pdfConfig.currentPage;
        });
        if (filteredRes &amp;&amp; filteredRes.length) {
          this.rangeService.deserialization(filteredRes);
        } else {
          // console.log(&quot;Nothing to deserilize:&quot; + filteredRes);
        }
      }, 200);
    } else {
      // this.notificationService.notify(&quot;Nothing to deserilize&quot;, &quot;warning&quot;);
    }
  }
  // Unique values filtering from array
  uniqueListFromArray(arr) {
    if (arr.length) {
      const finalArr: any[] &#x3D; arr.filter((item, i, ar) &#x3D;&gt; ar.indexOf(item) &#x3D;&#x3D;&#x3D; i);
      if (this.pdfPayload.ignorePages.length) {
        this.pdfPayload.ignorePages.forEach((item) &#x3D;&gt; {
          const index &#x3D; finalArr.indexOf(item);
          if (index !&#x3D;&#x3D; -1) finalArr.splice(index, 1);
        });
        if (Array.isArray(finalArr)) {
          finalArr.sort(function (a, b) {
            return a - b;
          });
        }
        return finalArr.toString();
      }
      if (finalArr.length &gt; 20) {
        if (Array.isArray(finalArr)) {
          finalArr.sort(function (a, b) {
            return a - b;
          });
        }
        const firstArr &#x3D; finalArr.slice(0, 20);
        const moreTxt &#x3D; &#x27;...&#x27;;
        const result &#x3D; firstArr.concat(moreTxt);
        return join(result);
      } else {
        if (Array.isArray(finalArr)) {
          finalArr.sort(function (a, b) {
            return a - b;
          });
        }
        return finalArr.toString();
      }
    }
    return 0;
  }
  tooltipText(arr) {
    if (arr) {
      const finalArr: any[] &#x3D; arr.filter((item, i, ar) &#x3D;&gt; ar.indexOf(item) &#x3D;&#x3D;&#x3D; i);
      if (this.pdfPayload.ignorePages.length) {
        this.pdfPayload.ignorePages.forEach((item) &#x3D;&gt; {
          const index &#x3D; finalArr.indexOf(item);
          if (index !&#x3D;&#x3D; -1) finalArr.splice(index, 1);
        });
        if (Array.isArray(finalArr)) {
          finalArr.sort(function (a, b) {
            return a - b;
          });
        }
        return finalArr.toString();
      } else {
        if (Array.isArray(finalArr)) {
          finalArr.sort(function (a, b) {
            return a - b;
          });
        }
        return finalArr.toString();
      }
    } else {
      return 0;
    }
  }
  ignoredPages(arr) {
    arr.sort(function (a, b) {
      return a - b;
    });
    return arr || [];
  }
  // Color picker theme
  createThemeForm() {
    this.form &#x3D; this._formBuilder.group({
      heading: [&#x27;#1372ff&#x27;],
      header: [&#x27;#f5a623&#x27;],
      footer: [&#x27;#09a624&#x27;],
      exclude: [&#x27;#ff5d5d&#x27;],
    });
  }
  applyTheme(stylesheet) {
    // Option Styles
    if (stylesheet.heading) {
      this.themeWrapper.style.setProperty(&#x27;--headingColor&#x27;, stylesheet.heading);
    }
    if (stylesheet.header) {
      this.themeWrapper.style.setProperty(&#x27;--headerColor&#x27;, stylesheet.header);
    }
    if (stylesheet.footer) {
      this.themeWrapper.style.setProperty(&#x27;--footerColor&#x27;, stylesheet.footer);
    }
    if (stylesheet.exclude) {
      this.themeWrapper.style.setProperty(&#x27;--excludeColor&#x27;, stylesheet.exclude);
    }
  }
}

interface SelectionRectangle {
  left: number;
  top: number;
  width: number;
  height: number;
}
// ENUMS
enum ClassTypes {
  heading &#x3D; &#x27;heading-highlight&#x27;,
  header &#x3D; &#x27;header-highlight&#x27;,
  footer &#x3D; &#x27;footer-highlight&#x27;,
  exclude &#x3D; &#x27;exclude-highlight&#x27;,
}
function getSelectionText() {
  const document: any &#x3D; window.document;
  if (window.getSelection) {
    try {
      const activeElement &#x3D; document.activeElement;
      if (activeElement &amp;&amp; activeElement.value) {
        return activeElement.value.substring(
          activeElement.selectionStart,
          activeElement.selectionEnd
        );
      } else {
        return window.getSelection().toString();
      }
    } catch (e) {}
  } else if (document.selection &amp;&amp; document.selection.type !&#x3D; &#x27;Control&#x27;) {
    return document.selection.createRange().text; // For IE
  }
}

// Get next, prev &amp; curr Siblings text from current element
function getAllElements(element, className, payload) {
  // Current
  const resultText: string &#x3D; element.textContent;
  if (findMatchedData(payload, &#x27;&#x27;, resultText, &#x27;&#x27;, className).isMatched) {
    const findMatchedObj: IFindMatched &#x3D; findMatchedData(
      payload,
      &#x27;&#x27;,
      resultText,
      &#x27;&#x27;,
      className
    );
    if (
      findMatchedObj.isMatched &amp;&amp;
      findMatchedObj.findText &amp;&amp;
      findMatchedObj.option
    ) {
      return findMatchedObj.findText || &#x27;&#x27;;
    }
    return resultText;
  }
  // PREV
  const prevResultText &#x3D; [];
  const lp &#x3D; $(&#x27;.&#x27; + className).length;
  let prevEle: any &#x3D; $(element).parent().prev().children();
  if ($(prevEle).hasClass(className)) {
    for (let i &#x3D; 0; i &lt; lp; i++) {
      for (let j &#x3D; prevEle.length; j &gt; 0; j--) {
        if (prevEle.length &amp;&amp; $(prevEle).hasClass(className)) {
          const text &#x3D; $(prevEle).text();
          prevResultText.push(text);
          if (
            findMatchedData(
              payload,
              prevResultText,
              resultText,
              nextResultText,
              className
            ).isMatched
          ) {
            prevEle &#x3D; {};
            const findMatchedObj: IFindMatched &#x3D; findMatchedData(
              payload,
              prevResultText,
              resultText,
              nextResultText,
              className
            );
            if (
              findMatchedObj.isMatched &amp;&amp;
              findMatchedObj.findText &amp;&amp;
              findMatchedObj.option
            ) {
              return findMatchedObj.findText || &#x27;&#x27;;
            }
          } else {
            prevEle &#x3D; $(prevEle).parent().prev().children(); // set every div this ele
          }
        }
      }
    }
  }
  // NEXT
  var nextResultText &#x3D; [];
  let nextEle: any &#x3D; $(element).parent().next().children();
  if ($(nextEle).hasClass(className)) {
    for (let i &#x3D; 0; i &lt; lp; i++) {
      for (let j &#x3D; 0; j &lt; nextEle.length; j++) {
        if (nextEle.length &amp;&amp; $(nextEle).hasClass(className)) {
          const text &#x3D; $(nextEle).text();
          nextResultText.push(text);
          if (
            findMatchedData(
              payload,
              prevResultText,
              resultText,
              nextResultText,
              className
            ).isMatched
          ) {
            nextEle &#x3D; {};
            const findMatchedObj: IFindMatched &#x3D; findMatchedData(
              payload,
              prevResultText,
              resultText,
              nextResultText,
              className
            );
            if (
              findMatchedObj.isMatched &amp;&amp;
              findMatchedObj.findText &amp;&amp;
              findMatchedObj.option
            ) {
              return findMatchedObj.findText || &#x27;&#x27;;
            }
          } else {
            nextEle &#x3D; $(nextEle).parent().next().children(); // set every div this element
          }
        }
      }
    }
  }

  const prvTxt &#x3D; prevResultText.reverse().join(&#x27;&#x27;) || &#x27;&#x27;;
  const nxtText &#x3D; nextResultText.join(&#x27;&#x27;) || &#x27;&#x27;;
  const finalText &#x3D; prvTxt + resultText + nxtText;
  return finalText || &#x27;&#x27;;
}
// Remove/Detach classes for Prev+ current + next elements span&#x27;s
function removeTextClass(className, element) {
  // CURRENT
  if (
    $(element).prev().hasClass(&#x27;rangySelectionBoundary&#x27;) &amp;&amp;
    $(element).next().hasClass(&#x27;rangySelectionBoundary&#x27;)
  ) {
    // Check prev &amp; next with rangyBoundry class
    $(element)
      .prev(&#x27;.rangySelectionBoundary&#x27;)
      .detach(&#x27;.rangySelectionBoundary&#x27;);
    $(element)
      .next(&#x27;.rangySelectionBoundary&#x27;)
      .detach(&#x27;.rangySelectionBoundary&#x27;);
  }
  $(element).removeClass(className);
  $(element).toggleClass(&#x27;rangy&#x27;);
  // PREV
  const lp &#x3D; $(&#x27;.&#x27; + className).length;
  let prevEle: any &#x3D; $(element).parent().prev().children();
  let nextEle: any &#x3D; $(element).parent().next().children();
  if ($(prevEle).hasClass(className)) {
    for (let i &#x3D; 0; i &lt; lp; i++) {
      for (let j &#x3D; prevEle.length; j &gt; 0; j--) {
        if ($(prevEle).hasClass(&#x27;rangySelectionBoundary&#x27;)) {
          prevEle &#x3D; $.each(prevEle, (index, ele) &#x3D;&gt; {
            if (ele.className &#x3D;&#x3D; &#x27;rangySelectionBoundary&#x27;) {
              $(ele).detach(&#x27;.rangySelectionBoundary&#x27;);
              $(ele).toggleClass(&#x27;rangy&#x27;);
            }
          });
        }
        if ($(prevEle).hasClass(className)) {
          $(prevEle).removeClass(className); // remove claas
          $(prevEle).toggleClass(&#x27;rangy&#x27;);
          prevEle &#x3D; $(prevEle).parent().prev().children(); // set every div this ele
        } else if (
          !$(prevEle).hasClass(className) &amp;&amp;
          $(prevEle).has(&#x27;span&#x27;).length
        ) {
          $(prevEle).removeClass(className); // remove claas
          $(prevEle).toggleClass(&#x27;rangy&#x27;);
          prevEle &#x3D; $(prevEle).parent().prev().children(); // set every div this ele
        }
      }
    }
  }
  // NEXT
  if ($(nextEle).hasClass(className)) {
    for (let i &#x3D; 0; i &lt; lp; i++) {
      for (let j &#x3D; 0; j &lt; nextEle.length; j++) {
        if ($(nextEle).hasClass(&#x27;rangySelectionBoundary&#x27;)) {
          nextEle &#x3D; $.each(nextEle, (index, ele) &#x3D;&gt; {
            if (ele.className &#x3D;&#x3D; &#x27;rangySelectionBoundary&#x27;) {
              $(ele).detach(&#x27;.rangySelectionBoundary&#x27;);
            }
          });
        }
        if ($(nextEle).hasClass(className)) {
          $(nextEle).removeClass(className); // remove claas
          $(nextEle).toggleClass(&#x27;rangy&#x27;);
          nextEle &#x3D; $(nextEle).parent().next().children(); // set every div this element
        } else if (
          !$(nextEle).hasClass(className) &amp;&amp;
          $(nextEle).has(&#x27;span&#x27;).length
        ) {
          $(nextEle).removeClass(className); // remove claas
          $(nextEle).toggleClass(&#x27;rangy&#x27;);
          nextEle &#x3D; $(nextEle).parent().next().children(); // set every div this element
        }
      }
    }
  }
}
// join array
function join(arr, last?) {
  if (!Array.isArray(arr)) throw &#x27;Passed value is not of array type.&#x27;;
  last &#x3D; last || &#x27; &#x27;;

  return arr.reduce(function (acc, value, index) {
    if (arr.length &lt; 2) return arr.join();
    return (
      acc +
      (index &gt;&#x3D; arr.length - 2
        ? index &gt; arr.length - 2
          ? value
          : value + last
        : value + &#x27;,&#x27;)
    );
  }, &#x27;&#x27;);
}
// find hasClass from multip divs
function checkDuplicateClasses(contentHtml: string) {
  try {
    if (
      contentHtml.toLocaleLowerCase().indexOf(ClassTypes.heading) !&#x3D;&#x3D; -1 ||
      contentHtml.toLocaleLowerCase().indexOf(ClassTypes.header) !&#x3D;&#x3D; -1 ||
      contentHtml.toLocaleLowerCase().indexOf(ClassTypes.footer) !&#x3D;&#x3D; -1 ||
      contentHtml.toLocaleLowerCase().indexOf(ClassTypes.exclude) !&#x3D;&#x3D; -1
    ) {
      return true;
    } else {
      return false;
    }
  } catch (ex) {}
}
// Find Matched Data from orignal payload
function findMatchedData(
  payload,
  prevText,
  currText,
  nextText,
  className
): IFindMatched {
  const prvTxt &#x3D; prevText &amp;&amp; prevText.length ? prevText.reverse().join(&#x27;&#x27;) : &#x27;&#x27;;
  const nxtText &#x3D; nextText &amp;&amp; nextText.length ? nextText.join(&#x27;&#x27;) : &#x27;&#x27;;
  const finalText &#x3D; prvTxt + currText + nxtText;
  let resultObj: IFindMatched &#x3D; {
    isMatched: true,
    option: null,
    index: null,
    findText: &#x27;&#x27;,
  };
  if (finalText) {
    if (payload.title.includes(finalText)) {
      return resultObj;
    } else if (payload.header.includes(finalText)) {
      return resultObj;
    } else if (payload.footer.includes(finalText)) {
      return resultObj;
    } else if (payload.ignoreText.includes(finalText)) {
      return resultObj;
    } else {
      resultObj.isMatched &#x3D; false;
    }
    if (!resultObj.isMatched) {
      if (payload.title.length) {
        payload.title.forEach((item, index) &#x3D;&gt; {
          const subStr &#x3D; item.substr(finalText, finalText.length);
          if (subStr &amp;&amp; payload.title.includes(subStr)) {
            resultObj &#x3D; {
              isMatched: true,
              option: &#x27;title&#x27;,
              index: index,
              findText: subStr,
            };
          }
        });
      } else if (payload.header.length) {
        payload.header.forEach((item, index) &#x3D;&gt; {
          const subStr &#x3D; item.substr(finalText, finalText.length);
          if (subStr &amp;&amp; payload.header.includes(subStr)) {
            resultObj &#x3D; {
              isMatched: true,
              option: &#x27;header&#x27;,
              index: index,
              findText: subStr,
            };
          }
        });
      } else if (payload.footer.length) {
        payload.footer.forEach((item, index) &#x3D;&gt; {
          const subStr &#x3D; item.substr(finalText, finalText.length);
          if (subStr &amp;&amp; payload.footer.includes(subStr)) {
            resultObj &#x3D; {
              isMatched: true,
              option: &#x27;footer&#x27;,
              index: index,
              findText: subStr,
            };
          }
        });
      } else if (payload.ignoreText.length) {
        payload.ignoreText.forEach((item, index) &#x3D;&gt; {
          const subStr &#x3D; item.substr(finalText, finalText.length);
          if (subStr &amp;&amp; payload.ignoreText.includes(subStr)) {
            resultObj &#x3D; {
              isMatched: true,
              option: &#x27;ignoreText&#x27;,
              index: index,
              findText: subStr,
            };
          }
        });
      }
      return resultObj;
    }
  }
}
// Remove text match obj
interface IFindMatched {
  isMatched: boolean;
  option: string | null;
  index: number | null;
  findText: string | null;
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'SelectionRectangle.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
